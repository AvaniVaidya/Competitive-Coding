{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs32 \cf2 \expnd0\expndtw0\kerning0
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\
\'a0\
\'a0\
\'a0\
Example 1:\
\'a0\
Input: n = 3\
Output: ["((()))","(()())","(())()","()(())","()()()"]\
Example 2:\
\'a0\
Input: n = 1\
Output: ["()"]\
\'a0\
\'a0\
Constraints:\
\'a0\
1 <= n <= 8\
\
===========================================================\
\
class Solution \{\
\'a0\
\'a0\'a0\'a0 public List<String> recursiveParenthesis(List<String> combinations, String s, int co, int cc, int n)\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(cc == n)\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 combinations.add(s);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return combinations;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(cc < co)\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recursiveParenthesis(combinations, s+")", co, cc+1, n);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(co < n)\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recursiveParenthesis(combinations, s+"(", co+1, cc, n);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return combinations;\
\'a0\'a0\'a0 \}\
\'a0\
\'a0\'a0\'a0 public List<String> generateParenthesis(int n) \{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0 List<String> combinations = new ArrayList<String>();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0 combinations = recursiveParenthesis(combinations, "", 0, 0, n);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return combinations;\
\'a0\'a0\'a0 \}\
\}\
}